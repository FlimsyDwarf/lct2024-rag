# Описание работы пайплайна RAG системы

Схема приложения:

<img width="693" alt="CF-RAG copy" src="https://github.com/MisterAndry/lct2024-rag/assets/66780351/81461cd2-805a-468c-9ec9-b418d336424f">

Data search pipeline:

<img width="1336" alt="CF-RAG" src="https://github.com/MisterAndry/lct2024-rag/assets/9989672/b064e550-48a4-4a62-beec-805e051332ad">

Пайплайн если поиск только по документам пользователя и по пользовательским ссылкам:

<img width="728" alt="CF-RAG_1" src="https://github.com/MisterAndry/lct2024-rag/assets/9989672/ab13f35e-0160-4a72-bc17-15f74c82ddee">

## Что используем
1. **LLM Framework**: LangChain
2. **LLM**: Chat GPT4o API
3. **Embedder**: OpenAI Embedding - text-embedding-3-large
4. **VectorStore**: Faiss
5. **Web-search**: Jina AI + Tavily search
6. **PDF parser**: PuMyPDF
7. **DOCX parser**: python-docx

## Порядок выполнения
1. Парсинг файла шаблона от пользователя - **File parser script**
  
    1. **Первые строки**
      - Сохранение **заголовка** из *первой строки файла шаблона*. Такой же заголовок будет в файле отчета
      - Сохранение **главной темы анализа** из *второй строки файла шаблона*. Тема будет использована для формирования *полного вопроса* к модели
    2. **Блоки**
      - По ключевому слову «Блок» производится поиск отдельного блока:
        1. Сохранение **названия блока** из *первой строки блока*(она начинается с ключевого слова «Блок»). Такое же название блока будет в файле отчета
        2. Извлечение и сохранение **пользовательского запроса** из каждого *пункта нумерации или маркировки в теле блока*. Этот запрос будет использован для формирования **полного вопроса** к модели

2. **Формирование *полного вопроса* к модели** - **Compose query**
    - Композиция из **главной темы анализа**, **названия блока** без ключвого слова «Блок» и **пользовательского запроса**

3. Поиск информации по каждому **сформированному запросу** - **Data search pipeline**

    1. **Инициализация и заполнение векторного хранилища**
      - Парсинг сайтов (**Jina AI**), полученных от пользователя, и парсинг документов пользователя (**PuMyPDF**).
      - Эмбеддинг полученных данных (**text-embedding-3-large**) и помещение их в векторное хранилище (**Faiss**)
    2. **Разделение вопросов** - **Pre-processing with ChatGPT**
      - Исходный запрос при помощи LLM делится на отдельные вопросы с учетом заданного диапазона дат (если пользователь указал временные рамки поиска информации для отчёта)
    3. **Процессинг запросов**
      - Для каждого вопроса выполняется поиск релевантных документов в векторном хранилище + поиск в инетрнете, если пользователь поставил галочку **Search in the internet** в UI
      - Все найденные документы фильтруются и ранжируются
      - На основе найденной информации генерерируется первоначальный ответ на вопрос
      - Проверка не галлюцинирует ли LLM (проверяет саму себя - насколько ответ обоснован и подкреплен набором фактом):
        - если не отвечает, то LLM переформулирует вопрос, и инициирует поиск информации в интернете с новым вопросом. Пункт 3 начинается сначала
        - если отвечает, то делает последнюю проверку - насколько ответ полезен для решения вопроса. Если не полезен, то LLM переформулирует вопрос, и инициирует поиск информации в интернете с новым вопросом. Пункт 3 начинается сначала.
        - если пункт 3 был выполнен три раза и ответ не был найдет, то используем последний сгенерированный ответ и переходим в п.4
    4. **Вывод результатов**
      - Результаты собираются в словарь, где ключами являются вопросы, а значениями — ответы. Этот словарь отправялется в генератор отчёта.
  
  Граф позволяет гибко и эффективно обрабатывать сложные запросы, используя промпт-инжиниринг и многоэтапный подход.

4. Суммаризация ответов модели на созданные ей же запросы в п.2 **Data search pipeline** для ответа на **сформированный запрос** - **Post-processing with ChatGPT**
    - **Суммаризация ответов** с помощью LLM в один ответ на **сформированный запрос**
    - Сбор **источников**, по которым производился поиск в контексте данного **сформированного запроса**
  
5. Формирование конечного отчета - **File generate script**

    1. **Первые строки**
      - Заполнение **заголовка** в *первую строку файла отчета*.
      - Заполнение **главной темы анализа** во *вторую строку файла отчета*.
    2. **Блоки**
      - Для каждого блока из шаблона создается отдельный блок в *файле отчета*:
        1. Заполнение **названия блока** в *первую строку блоку*.
        2. Заполнение ответа на каждый **пользовательский запрос** в формате:
             1. **Суммаризованные ответы**
             2. **Источники**
